<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Hardware Abstraction Layer (HAL)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Hardware Abstraction Layer (HAL)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__group__hal__flash.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">API Reference</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Flash (Flash System Routine)<div class="ingroups"><a class="el" href="group__group__hal.html">HAL Drivers</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<p>High level interface to the internal flash memory. </p>
<p>Flash memory provides non-volatile storage for user firmware, user configuration data, and bulk data storage.</p>
<p>This driver allows data to be read from and written to flash. It also provides the ability to obtain information about the address and characteristics of the flash block(s) contained on the device. During flash write time, the device should not be reset (including XRES pin, software reset, and watchdog) or unexpected changes may be made to portions of the flash. Also, the low-voltage detect circuits should be configured to generate an interrupt instead of a reset.</p>
<dl class="section note"><dt>Note</dt><dd>A Read while Write violation may occur for some devices when a flash Read operation is initiated in the same or neighboring flash sector where the flash Write, Erase, or Program operation is working. Refer the the device datasheet for more information. This violation may cause a HardFault exception. To avoid the Read while Write violation, the user must carefully split the Read and Write operations on flash sectors which are not neighboring, considering all cores in a multi-processor device. You may edit the linker script to place the code into neighboring sectors. For example, use sectors number 0 and 1 for code and sectors 2 and 3 for data storage.</dd></dl>
<h1><a class="anchor" id="features"></a>
Features</h1>
<ul>
<li>Flash operations are performed on a per-sector basis</li>
<li>Supports blocking or partially blocking erase, program and write </li>
</ul>
<h1><a class="anchor" id="code_snippet"></a>
Code Snippets</h1>
<h2><a class="anchor" id="subsection_flash_use_case_1"></a>
Snippet 1: Discovering flash characteristics</h2>
<p>Following code snippet demonstrates how to discover flash characteristics. Refer <a class="el" href="group__group__hal__flash.html#structcyhal__flash__info__t">cyhal_flash_info_t</a> for more information. </p><div class="fragment"><div class="line"></div><div class="line">    <a class="code" href="group__group__hal__impl__hw__types.html#structcyhal__flash__t">cyhal_flash_t</a> flash_obj;</div><div class="line">    <a class="code" href="group__group__hal__flash.html#structcyhal__flash__info__t">cyhal_flash_info_t</a> flash_info;</div><div class="line">    uint32_t flash_start_address;</div><div class="line">    uint32_t flash_size;</div><div class="line">    uint32_t flash_sector_size;</div><div class="line">    uint32_t flash_page_size;</div><div class="line">    uint8_t flash_erase_value;</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize flash object */</span></div><div class="line">    <a class="code" href="group__group__hal__flash.html#ga669e3789204d0cf9610a85f26a28c55b">cyhal_flash_init</a>(&amp;flash_obj);</div><div class="line"></div><div class="line">    <span class="comment">/* Get flash characteristics */</span></div><div class="line">    <a class="code" href="group__group__hal__flash.html#gaab923541b1d1f71b0b9545306a9c559a">cyhal_flash_get_info</a>(&amp;flash_obj, &amp;flash_info);</div><div class="line"></div><div class="line">    <span class="comment">/* Wait for 100ms for the flash write to complete */</span></div><div class="line">    uint32_t timeout = 100;</div><div class="line"></div><div class="line">    <span class="comment">/* Wait for the command to finish execution */</span></div><div class="line">    <span class="keywordflow">while</span>((<span class="keyword">true</span> != <a class="code" href="group__group__hal__flash.html#gad3f9a6b2b2af077d862c98bb7aa624ac">cyhal_flash_is_operation_complete</a>(&amp;flash_obj)) &amp;&amp; (0 &lt; timeout))</div><div class="line">    {</div><div class="line">        timeout--;</div><div class="line">        <a class="code" href="group__group__hal__system.html#ga5f450769c1207d98134a9ced39adfdda">cyhal_system_delay_ms</a>(1); <span class="comment">/* delay one millisecond each iteration */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(0 != timeout)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> index = 0; index &lt; flash_info.<a class="code" href="group__group__hal__flash.html#a4084c53e5f07ca60c8fb3bcbb2af11a4">block_count</a>; index++)</div><div class="line">        {</div><div class="line">            <span class="keyword">const</span> <a class="code" href="group__group__hal__flash.html#structcyhal__flash__block__info__t">cyhal_flash_block_info_t</a> *block_info = flash_info.<a class="code" href="group__group__hal__flash.html#abf8824c2c183140e0904dec90cffe877">blocks</a>;</div><div class="line">            block_info += index;</div><div class="line">            flash_start_address = block_info-&gt;<a class="code" href="group__group__hal__flash.html#a7066dc8bfd2f85ba0a0a8fa61afe9a9d">start_address</a>;</div><div class="line">            flash_size = block_info-&gt;<a class="code" href="group__group__hal__flash.html#a28cdf0683abfa135ae3711631cb137a7">size</a>;</div><div class="line">            flash_sector_size = block_info-&gt;<a class="code" href="group__group__hal__flash.html#ab007e1eb95459c533ed133bb982eaac5">sector_size</a>;</div><div class="line">            flash_page_size = block_info-&gt;<a class="code" href="group__group__hal__flash.html#a50f22883955ce253d7910ca94dcd654d">page_size</a>;</div><div class="line">            flash_erase_value = block_info-&gt;<a class="code" href="group__group__hal__flash.html#a736a77cdecefcca007609dd7b73b9996">erase_value</a>;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --> <h2><a class="anchor" id="subsection_flash_use_case_2"></a>
Snippet 2: Blocking Flash Write Operation</h2>
<p>Following code snippet demonstrates blocking flash write. It uses a constant array with a size equaling the size of one flash row. This array is placed at an address in flash such that it occupies one complete flash row. It uses blocking flash write operation which blocks the caller until the write is completed. It then verifies the flash data by comparing the flash data with the written data. </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Use cyhal_flash_get_info() to obtain values for the particular device */</span></div><div class="line"><span class="preprocessor">    #define FLASH_START_ADDR        (0x10000000)</span></div><div class="line"><span class="preprocessor">    #define FLASH_SIZE              (0x100000)</span></div><div class="line"><span class="preprocessor">    #define FLASH_PAGE_SIZE         (512)</span></div><div class="line"><span class="preprocessor">    #define LAST_FLASH_ROW          ((FLASH_SIZE/FLASH_PAGE_SIZE) - 1)</span></div><div class="line"></div><div class="line">    <span class="comment">/* This array reserves space in the flash for one page of size</span></div><div class="line"><span class="comment">    * FLASH_PAGE_SIZE. Explicit initialization is required so that memory is</span></div><div class="line"><span class="comment">    * allocated in flash instead of RAM. */</span></div><div class="line"><span class="preprocessor">    #define CALCULATE_FLASH_ADDRESS(row_num) (FLASH_START_ADDR + ((row_num) * FLASH_PAGE_SIZE))</span></div><div class="line"></div><div class="line">    <span class="comment">/* Make the address point to last user flash page */</span></div><div class="line">    <span class="keyword">const</span> uint8_t *flash_data_ptr = (uint8_t *)CALCULATE_FLASH_ADDRESS(LAST_FLASH_ROW);</div><div class="line"></div><div class="line">    <a class="code" href="group__group__result.html#gaca79700fcc701534ce61778a9bcf57d1">cy_rslt_t</a> result;                               <span class="comment">/* Flash Write Status */</span></div><div class="line">    uint8_t ram_data[FLASH_PAGE_SIZE];              <span class="comment">/* RAM data to be written to Flash */</span></div><div class="line">    uint8_t flash_read_data[FLASH_PAGE_SIZE];       <span class="comment">/* RAM data read from Flash for validation */</span></div><div class="line">    <span class="keywordtype">bool</span> compare_status = <span class="keyword">false</span>;                    <span class="comment">/* Compare Status */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Flash object */</span></div><div class="line">    <a class="code" href="group__group__hal__impl__hw__types.html#structcyhal__flash__t">cyhal_flash_t</a> flash_obj;</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize flash object */</span></div><div class="line">    <a class="code" href="group__group__hal__flash.html#ga669e3789204d0cf9610a85f26a28c55b">cyhal_flash_init</a>(&amp;flash_obj);</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize the data in RAM that will be written into flash */</span></div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> index = 0; index &lt; FLASH_PAGE_SIZE; index++)</div><div class="line">    {</div><div class="line">        ram_data[index] = (uint8_t)index;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Blocking flash erase prior to flash write */</span></div><div class="line">    result = <a class="code" href="group__group__hal__flash.html#ga10b68f24a5c9a7c929a2c1fa3af89858">cyhal_flash_erase</a>(&amp;flash_obj, (uint32_t)flash_data_ptr);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(result != <a class="code" href="group__group__result.html#gaf58fac450d9fff4472f03ad68f6e546e">CY_RSLT_SUCCESS</a>)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Error erasing flash */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Blocking flash write */</span></div><div class="line">    result = <a class="code" href="group__group__hal__flash.html#ga622b0c7a66fb46946eedea821b5e12aa">cyhal_flash_write</a>(&amp;flash_obj, (uint32_t)flash_data_ptr, (<span class="keyword">const</span> uint32_t *)ram_data);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="group__group__result.html#gaf58fac450d9fff4472f03ad68f6e546e">CY_RSLT_SUCCESS</a> == result)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Read flash data */</span></div><div class="line">        result = <a class="code" href="group__group__hal__flash.html#gab21b7e9300c5b630e9656f71decedaf8">cyhal_flash_read</a>(&amp;flash_obj, (uint32_t)flash_data_ptr, flash_read_data, <span class="keyword">sizeof</span>(flash_read_data));</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span>(<a class="code" href="group__group__result.html#gaf58fac450d9fff4472f03ad68f6e546e">CY_RSLT_SUCCESS</a> == result)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Verify the data written into flash by comparing it with the RAM data */</span></div><div class="line">            <span class="keywordflow">if</span>(0 == memcmp(ram_data, flash_read_data, <span class="keyword">sizeof</span>(flash_read_data)))</div><div class="line">            {</div><div class="line">                compare_status = <span class="keyword">true</span>;</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>It is recommended to declare the flash array as global variable.</dd></dl>
<h2><a class="anchor" id="subsection_flash_use_case_3"></a>
Snippet 3: Non-blocking Flash Write Operation using polling</h2>
<p>Following code snippet implements the non-blocking flash write using polling to complete the flash write operation. It uses a constant array with a size equaling the size of one flash row. This array is placed at an address in flash such that it occupies one complete flash row. It uses a polling method to complete the flash write operation. It then verifies the flash data by comparing the flash data with the written data. </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Use cyhal_flash_get_info() to obtain values for the particular device */</span></div><div class="line"><span class="preprocessor">    #define FLASH_START_ADDR        (0x10000000)</span></div><div class="line"><span class="preprocessor">    #define FLASH_SIZE              (0x100000)</span></div><div class="line"><span class="preprocessor">    #define FLASH_PAGE_SIZE         (512)</span></div><div class="line"><span class="preprocessor">    #define LAST_FLASH_ROW          ((FLASH_SIZE/FLASH_PAGE_SIZE) - 1)</span></div><div class="line"></div><div class="line">    <span class="comment">/* This array reserves space in the flash for one page of size</span></div><div class="line"><span class="comment">    * FLASH_PAGE_SIZE. Explicit initialization is required so that memory is</span></div><div class="line"><span class="comment">    * allocated in flash instead of RAM. */</span></div><div class="line"><span class="preprocessor">    #define CALCULATE_FLASH_ADDRESS(row_num) (FLASH_START_ADDR + ((row_num) * FLASH_PAGE_SIZE))</span></div><div class="line"></div><div class="line">    <span class="comment">/* Make the address point to last user flash page */</span></div><div class="line">    <span class="keyword">const</span> uint8_t *flash_data_ptr = (uint8_t *)CALCULATE_FLASH_ADDRESS(LAST_FLASH_ROW);</div><div class="line"></div><div class="line">    <a class="code" href="group__group__result.html#gaca79700fcc701534ce61778a9bcf57d1">cy_rslt_t</a> result;                               <span class="comment">/* Flash Write Status */</span></div><div class="line">    uint8_t ram_data[FLASH_PAGE_SIZE];              <span class="comment">/* RAM data to be written to Flash */</span></div><div class="line">    uint8_t flash_read_data[FLASH_PAGE_SIZE];       <span class="comment">/* RAM data read from Flash for validation */</span></div><div class="line">    <span class="keywordtype">bool</span> compare_status = <span class="keyword">false</span>;                    <span class="comment">/* Compare Status */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Flash object */</span></div><div class="line">    <a class="code" href="group__group__hal__impl__hw__types.html#structcyhal__flash__t">cyhal_flash_t</a> flash_obj;</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize flash object */</span></div><div class="line">    <a class="code" href="group__group__hal__flash.html#ga669e3789204d0cf9610a85f26a28c55b">cyhal_flash_init</a>(&amp;flash_obj);</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize the data in RAM that will be written into flash */</span></div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> index = 0; index &lt; FLASH_PAGE_SIZE; index++)</div><div class="line">    {</div><div class="line">        ram_data[index] = (uint8_t)index;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Wait for 100ms for the flash write to complete */</span></div><div class="line">    uint32_t timeout = 100;</div><div class="line"></div><div class="line">    <span class="comment">/* Partially blocking flash erase */</span></div><div class="line">    result = <a class="code" href="group__group__hal__flash.html#ga90697ece402e7e5f02303dbe568d0ba3">cyhal_flash_start_erase</a>(&amp;flash_obj, (uint32_t)flash_data_ptr);</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span>(<span class="keyword">true</span> != <a class="code" href="group__group__hal__flash.html#gad3f9a6b2b2af077d862c98bb7aa624ac">cyhal_flash_is_operation_complete</a>(&amp;flash_obj))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Wait for the flash erase to be successful */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Partially-blocking flash write */</span></div><div class="line">    result = <a class="code" href="group__group__hal__flash.html#ga7de934ab80e8fcb82554735c98da3665">cyhal_flash_start_write</a>(&amp;flash_obj, (uint32_t)flash_data_ptr, (<span class="keyword">const</span> uint32_t *)ram_data);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="group__group__result.html#gaf58fac450d9fff4472f03ad68f6e546e">CY_RSLT_SUCCESS</a> == result)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Wait for 100ms for the flash write to complete */</span></div><div class="line">        timeout = 100;</div><div class="line"></div><div class="line">        <span class="comment">/* Wait for the successful flash write */</span></div><div class="line">        <span class="keywordflow">while</span>((<span class="keyword">true</span> != <a class="code" href="group__group__hal__flash.html#gad3f9a6b2b2af077d862c98bb7aa624ac">cyhal_flash_is_operation_complete</a>(&amp;flash_obj)) &amp;&amp; (0 &lt; timeout))</div><div class="line">        {</div><div class="line">            timeout--;</div><div class="line">            <a class="code" href="group__group__hal__system.html#ga5f450769c1207d98134a9ced39adfdda">cyhal_system_delay_ms</a>(1); <span class="comment">/* delay one millisecond each iteration */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* Flag error if the expected flash write status not returned within timeout period */</span></div><div class="line">        <span class="keywordflow">if</span>(0 != timeout)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Read flash data */</span></div><div class="line">            result = <a class="code" href="group__group__hal__flash.html#gab21b7e9300c5b630e9656f71decedaf8">cyhal_flash_read</a>(&amp;flash_obj, (uint32_t)flash_data_ptr, flash_read_data, <span class="keyword">sizeof</span>(flash_read_data));</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span>(<a class="code" href="group__group__result.html#gaf58fac450d9fff4472f03ad68f6e546e">CY_RSLT_SUCCESS</a> == result)</div><div class="line">            {</div><div class="line">                <span class="comment">/* Verify the data written into flash by comparing it with the RAM data */</span></div><div class="line">                <span class="keywordflow">if</span>(0 == memcmp(ram_data, flash_read_data, <span class="keyword">sizeof</span>(flash_read_data)))</div><div class="line">                {</div><div class="line">                    compare_status = <span class="keyword">true</span>;</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>It is recommended to declare the flash array as global variable. </dd></dl>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
API Reference</h2></td></tr>
<tr class="memitem:group__group__hal__results__flash"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__hal__results__flash.html">Flash HAL Results</a></td></tr>
<tr class="memdesc:group__group__hal__results__flash"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flash specific return codes. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structcyhal__flash__block__info__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__hal__flash.html#structcyhal__flash__block__info__t">cyhal_flash_block_info_t</a></td></tr>
<tr class="memdesc:structcyhal__flash__block__info__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about a single block of flash memory.  <a href="group__group__hal__flash.html#structcyhal__flash__block__info__t">More...</a><br /></td></tr>
<tr class="separator:structcyhal__flash__block__info__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structcyhal__flash__info__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__hal__flash.html#structcyhal__flash__info__t">cyhal_flash_info_t</a></td></tr>
<tr class="memdesc:structcyhal__flash__info__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about all of the blocks of flash memory.  <a href="group__group__hal__flash.html#structcyhal__flash__info__t">More...</a><br /></td></tr>
<tr class="separator:structcyhal__flash__info__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga669e3789204d0cf9610a85f26a28c55b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__result.html#gaca79700fcc701534ce61778a9bcf57d1">cy_rslt_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__hal__flash.html#ga669e3789204d0cf9610a85f26a28c55b">cyhal_flash_init</a> (<a class="el" href="group__group__hal__impl__hw__types.html#structcyhal__flash__t">cyhal_flash_t</a> *obj)</td></tr>
<tr class="memdesc:ga669e3789204d0cf9610a85f26a28c55b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the <a class="el" href="group__group__hal__impl__hw__types.html#structcyhal__flash__t">cyhal_flash_t</a> object for accessing flash through the HAL.  <a href="#ga669e3789204d0cf9610a85f26a28c55b">More...</a><br /></td></tr>
<tr class="separator:ga669e3789204d0cf9610a85f26a28c55b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27db9641684bfa6d0b64088448b8e050"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__hal__flash.html#ga27db9641684bfa6d0b64088448b8e050">cyhal_flash_free</a> (<a class="el" href="group__group__hal__impl__hw__types.html#structcyhal__flash__t">cyhal_flash_t</a> *obj)</td></tr>
<tr class="memdesc:ga27db9641684bfa6d0b64088448b8e050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free resources associated with flash object through the HAL.  <a href="#ga27db9641684bfa6d0b64088448b8e050">More...</a><br /></td></tr>
<tr class="separator:ga27db9641684bfa6d0b64088448b8e050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab923541b1d1f71b0b9545306a9c559a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__hal__flash.html#gaab923541b1d1f71b0b9545306a9c559a">cyhal_flash_get_info</a> (const <a class="el" href="group__group__hal__impl__hw__types.html#structcyhal__flash__t">cyhal_flash_t</a> *obj, <a class="el" href="group__group__hal__flash.html#structcyhal__flash__info__t">cyhal_flash_info_t</a> *info)</td></tr>
<tr class="memdesc:gaab923541b1d1f71b0b9545306a9c559a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets flash characteristics like the start address, size, erase values etc.  <a href="#gaab923541b1d1f71b0b9545306a9c559a">More...</a><br /></td></tr>
<tr class="separator:gaab923541b1d1f71b0b9545306a9c559a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab21b7e9300c5b630e9656f71decedaf8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__result.html#gaca79700fcc701534ce61778a9bcf57d1">cy_rslt_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__hal__flash.html#gab21b7e9300c5b630e9656f71decedaf8">cyhal_flash_read</a> (<a class="el" href="group__group__hal__impl__hw__types.html#structcyhal__flash__t">cyhal_flash_t</a> *obj, uint32_t address, uint8_t *data, size_t size)</td></tr>
<tr class="memdesc:gab21b7e9300c5b630e9656f71decedaf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data starting at a defined address.  <a href="#gab21b7e9300c5b630e9656f71decedaf8">More...</a><br /></td></tr>
<tr class="separator:gab21b7e9300c5b630e9656f71decedaf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10b68f24a5c9a7c929a2c1fa3af89858"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__result.html#gaca79700fcc701534ce61778a9bcf57d1">cy_rslt_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__hal__flash.html#ga10b68f24a5c9a7c929a2c1fa3af89858">cyhal_flash_erase</a> (<a class="el" href="group__group__hal__impl__hw__types.html#structcyhal__flash__t">cyhal_flash_t</a> *obj, uint32_t address)</td></tr>
<tr class="memdesc:ga10b68f24a5c9a7c929a2c1fa3af89858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase one page starting at a defined address.  <a href="#ga10b68f24a5c9a7c929a2c1fa3af89858">More...</a><br /></td></tr>
<tr class="separator:ga10b68f24a5c9a7c929a2c1fa3af89858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga622b0c7a66fb46946eedea821b5e12aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__result.html#gaca79700fcc701534ce61778a9bcf57d1">cy_rslt_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__hal__flash.html#ga622b0c7a66fb46946eedea821b5e12aa">cyhal_flash_write</a> (<a class="el" href="group__group__hal__impl__hw__types.html#structcyhal__flash__t">cyhal_flash_t</a> *obj, uint32_t address, const uint32_t *data)</td></tr>
<tr class="memdesc:ga622b0c7a66fb46946eedea821b5e12aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function erases the page and writes the new data into the page starting at a defined address.  <a href="#ga622b0c7a66fb46946eedea821b5e12aa">More...</a><br /></td></tr>
<tr class="separator:ga622b0c7a66fb46946eedea821b5e12aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66a23d2dfbe01d027f8e9318999b7e19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__result.html#gaca79700fcc701534ce61778a9bcf57d1">cy_rslt_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__hal__flash.html#ga66a23d2dfbe01d027f8e9318999b7e19">cyhal_flash_program</a> (<a class="el" href="group__group__hal__impl__hw__types.html#structcyhal__flash__t">cyhal_flash_t</a> *obj, uint32_t address, const uint32_t *data)</td></tr>
<tr class="memdesc:ga66a23d2dfbe01d027f8e9318999b7e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Program one page with given data starting at defined address.  <a href="#ga66a23d2dfbe01d027f8e9318999b7e19">More...</a><br /></td></tr>
<tr class="separator:ga66a23d2dfbe01d027f8e9318999b7e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90697ece402e7e5f02303dbe568d0ba3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__result.html#gaca79700fcc701534ce61778a9bcf57d1">cy_rslt_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__hal__flash.html#ga90697ece402e7e5f02303dbe568d0ba3">cyhal_flash_start_erase</a> (<a class="el" href="group__group__hal__impl__hw__types.html#structcyhal__flash__t">cyhal_flash_t</a> *obj, uint32_t address)</td></tr>
<tr class="memdesc:ga90697ece402e7e5f02303dbe568d0ba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts an asynchronous erase of a single page of flash.  <a href="#ga90697ece402e7e5f02303dbe568d0ba3">More...</a><br /></td></tr>
<tr class="separator:ga90697ece402e7e5f02303dbe568d0ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7de934ab80e8fcb82554735c98da3665"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__result.html#gaca79700fcc701534ce61778a9bcf57d1">cy_rslt_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__hal__flash.html#ga7de934ab80e8fcb82554735c98da3665">cyhal_flash_start_write</a> (<a class="el" href="group__group__hal__impl__hw__types.html#structcyhal__flash__t">cyhal_flash_t</a> *obj, uint32_t address, const uint32_t *data)</td></tr>
<tr class="memdesc:ga7de934ab80e8fcb82554735c98da3665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts an asynchronous write to a single page of flash.  <a href="#ga7de934ab80e8fcb82554735c98da3665">More...</a><br /></td></tr>
<tr class="separator:ga7de934ab80e8fcb82554735c98da3665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e2ea114a8c7be82e928938e962adce1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__result.html#gaca79700fcc701534ce61778a9bcf57d1">cy_rslt_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__hal__flash.html#ga1e2ea114a8c7be82e928938e962adce1">cyhal_flash_start_program</a> (<a class="el" href="group__group__hal__impl__hw__types.html#structcyhal__flash__t">cyhal_flash_t</a> *obj, uint32_t address, const uint32_t *data)</td></tr>
<tr class="memdesc:ga1e2ea114a8c7be82e928938e962adce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts asynchronous programming of a single page of flash.  <a href="#ga1e2ea114a8c7be82e928938e962adce1">More...</a><br /></td></tr>
<tr class="separator:ga1e2ea114a8c7be82e928938e962adce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3f9a6b2b2af077d862c98bb7aa624ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__hal__flash.html#gad3f9a6b2b2af077d862c98bb7aa624ac">cyhal_flash_is_operation_complete</a> (<a class="el" href="group__group__hal__impl__hw__types.html#structcyhal__flash__t">cyhal_flash_t</a> *obj)</td></tr>
<tr class="memdesc:gad3f9a6b2b2af077d862c98bb7aa624ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports status of the flash operation.  <a href="#gad3f9a6b2b2af077d862c98bb7aa624ac">More...</a><br /></td></tr>
<tr class="separator:gad3f9a6b2b2af077d862c98bb7aa624ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structcyhal__flash__block__info__t" id="structcyhal__flash__block__info__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structcyhal__flash__block__info__t">&#9670;&nbsp;</a></span>cyhal_flash_block_info_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct cyhal_flash_block_info_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a7066dc8bfd2f85ba0a0a8fa61afe9a9d"></a>uint32_t</td>
<td class="fieldname">
start_address</td>
<td class="fielddoc">
Start address of the memory. </td></tr>
<tr><td class="fieldtype">
<a id="a28cdf0683abfa135ae3711631cb137a7"></a>uint32_t</td>
<td class="fieldname">
size</td>
<td class="fielddoc">
Size of the flash memory. </td></tr>
<tr><td class="fieldtype">
<a id="ab007e1eb95459c533ed133bb982eaac5"></a>uint32_t</td>
<td class="fieldname">
sector_size</td>
<td class="fielddoc">
Sector size of the memory. </td></tr>
<tr><td class="fieldtype">
<a id="a50f22883955ce253d7910ca94dcd654d"></a>uint32_t</td>
<td class="fieldname">
page_size</td>
<td class="fielddoc">
Page size of the memory. </td></tr>
<tr><td class="fieldtype">
<a id="a736a77cdecefcca007609dd7b73b9996"></a>uint8_t</td>
<td class="fieldname">
erase_value</td>
<td class="fielddoc">
The flash erase value. </td></tr>
</table>

</div>
</div>
<a name="structcyhal__flash__info__t" id="structcyhal__flash__info__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structcyhal__flash__info__t">&#9670;&nbsp;</a></span>cyhal_flash_info_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct cyhal_flash_info_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a4084c53e5f07ca60c8fb3bcbb2af11a4"></a>uint8_t</td>
<td class="fieldname">
block_count</td>
<td class="fielddoc">
The number of distinct flash blocks. </td></tr>
<tr><td class="fieldtype">
<a id="abf8824c2c183140e0904dec90cffe877"></a>const <a class="el" href="group__group__hal__flash.html#structcyhal__flash__block__info__t">cyhal_flash_block_info_t</a> *</td>
<td class="fieldname">
blocks</td>
<td class="fielddoc">
Array of the distinct flash blocks. </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga669e3789204d0cf9610a85f26a28c55b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga669e3789204d0cf9610a85f26a28c55b">&#9670;&nbsp;</a></span>cyhal_flash_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__result.html#gaca79700fcc701534ce61778a9bcf57d1">cy_rslt_t</a> cyhal_flash_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__hal__impl__hw__types.html#structcyhal__flash__t">cyhal_flash_t</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the <a class="el" href="group__group__hal__impl__hw__types.html#structcyhal__flash__t">cyhal_flash_t</a> object for accessing flash through the HAL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">obj</td><td>Pointer to a flash object. The caller must allocate the memory for this object but the init function will initialize its contents. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status of the init request. Returns <a class="el" href="group__group__result.html#gaf58fac450d9fff4472f03ad68f6e546e">CY_RSLT_SUCCESS</a> on successful operation. </dd></dl>

</div>
</div>
<a id="ga27db9641684bfa6d0b64088448b8e050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27db9641684bfa6d0b64088448b8e050">&#9670;&nbsp;</a></span>cyhal_flash_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cyhal_flash_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__hal__impl__hw__types.html#structcyhal__flash__t">cyhal_flash_t</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free resources associated with flash object through the HAL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">obj</td><td>The flash object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaab923541b1d1f71b0b9545306a9c559a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab923541b1d1f71b0b9545306a9c559a">&#9670;&nbsp;</a></span>cyhal_flash_get_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cyhal_flash_get_info </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__group__hal__impl__hw__types.html#structcyhal__flash__t">cyhal_flash_t</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__hal__flash.html#structcyhal__flash__info__t">cyhal_flash_info_t</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets flash characteristics like the start address, size, erase values etc. </p>
<p>Refer <a class="el" href="group__group__hal__flash.html#structcyhal__flash__info__t">cyhal_flash_info_t</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>The flash object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>The flash characteristic info.</td></tr>
  </table>
  </dd>
</dl>
<p>Refer <a class="el" href="group__group__hal__flash.html#subsection_flash_use_case_1">Snippet 1: Discovering flash characteristics</a> for more information. </p>

</div>
</div>
<a id="gab21b7e9300c5b630e9656f71decedaf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab21b7e9300c5b630e9656f71decedaf8">&#9670;&nbsp;</a></span>cyhal_flash_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__result.html#gaca79700fcc701534ce61778a9bcf57d1">cy_rslt_t</a> cyhal_flash_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__hal__impl__hw__types.html#structcyhal__flash__t">cyhal_flash_t</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data starting at a defined address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>The flash object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Address to begin reading from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>The buffer to read data into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of bytes to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status of the read request. Returns <a class="el" href="group__group__result.html#gaf58fac450d9fff4472f03ad68f6e546e">CY_RSLT_SUCCESS</a> on successful operation.</dd></dl>
<p>Refer <a class="el" href="group__group__hal__flash.html#subsection_flash_use_case_2">Snippet 2: Blocking Flash Write Operation</a> for more information. </p>

</div>
</div>
<a id="ga10b68f24a5c9a7c929a2c1fa3af89858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10b68f24a5c9a7c929a2c1fa3af89858">&#9670;&nbsp;</a></span>cyhal_flash_erase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__result.html#gaca79700fcc701534ce61778a9bcf57d1">cy_rslt_t</a> cyhal_flash_erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__hal__impl__hw__types.html#structcyhal__flash__t">cyhal_flash_t</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase one page starting at a defined address. </p>
<p>The address must be at page boundary. This will block until the erase operation is complete.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__group__hal__flash.html#gaab923541b1d1f71b0b9545306a9c559a" title="Gets flash characteristics like the start address, size, erase values etc. ">cyhal_flash_get_info()</a> to get the flash characteristics for legal address values and the page erase size.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>The flash object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The page starting address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status of the erase request. Returns <a class="el" href="group__group__result.html#gaf58fac450d9fff4472f03ad68f6e546e">CY_RSLT_SUCCESS</a> on successful operation.</dd></dl>
<p>Refer <a class="el" href="group__group__hal__flash.html#subsection_flash_use_case_2">Snippet 2: Blocking Flash Write Operation</a> for more information. </p>

</div>
</div>
<a id="ga622b0c7a66fb46946eedea821b5e12aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga622b0c7a66fb46946eedea821b5e12aa">&#9670;&nbsp;</a></span>cyhal_flash_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__result.html#gaca79700fcc701534ce61778a9bcf57d1">cy_rslt_t</a> cyhal_flash_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__hal__impl__hw__types.html#structcyhal__flash__t">cyhal_flash_t</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function erases the page and writes the new data into the page starting at a defined address. </p>
<p>The address must be at page boundary. This will block until the write operation is complete.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__group__hal__flash.html#gaab923541b1d1f71b0b9545306a9c559a" title="Gets flash characteristics like the start address, size, erase values etc. ">cyhal_flash_get_info()</a> to get the flash characteristics for legal address values and the page write size. The provided data buffer must be at least as large as the flash page_size.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>The flash object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The page starting address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data to write to the flash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status of the write request. Returns <a class="el" href="group__group__result.html#gaf58fac450d9fff4472f03ad68f6e546e">CY_RSLT_SUCCESS</a> on successful operation.</dd></dl>
<p>Refer <a class="el" href="group__group__hal__flash.html#subsection_flash_use_case_2">Snippet 2: Blocking Flash Write Operation</a> for more information. </p>

</div>
</div>
<a id="ga66a23d2dfbe01d027f8e9318999b7e19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66a23d2dfbe01d027f8e9318999b7e19">&#9670;&nbsp;</a></span>cyhal_flash_program()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__result.html#gaca79700fcc701534ce61778a9bcf57d1">cy_rslt_t</a> cyhal_flash_program </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__hal__impl__hw__types.html#structcyhal__flash__t">cyhal_flash_t</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Program one page with given data starting at defined address. </p>
<p>The address must be at page boundary. This will block until the write operation is complete. </p><dl class="section note"><dt>Note</dt><dd>This function does not erase the page prior to writing. The page must be erased first via a separate call to erase.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__group__hal__flash.html#gaab923541b1d1f71b0b9545306a9c559a" title="Gets flash characteristics like the start address, size, erase values etc. ">cyhal_flash_get_info()</a> to get the flash characteristics for legal address values and the total page size. The provided data buffer must be at least as large as the flash page_size.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>The flash object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The sector starting address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data buffer to be programmed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status of the program request. Returns <a class="el" href="group__group__result.html#gaf58fac450d9fff4472f03ad68f6e546e">CY_RSLT_SUCCESS</a> on successful operation. </dd></dl>

</div>
</div>
<a id="ga90697ece402e7e5f02303dbe568d0ba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90697ece402e7e5f02303dbe568d0ba3">&#9670;&nbsp;</a></span>cyhal_flash_start_erase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__result.html#gaca79700fcc701534ce61778a9bcf57d1">cy_rslt_t</a> cyhal_flash_start_erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__hal__impl__hw__types.html#structcyhal__flash__t">cyhal_flash_t</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts an asynchronous erase of a single page of flash. </p>
<p>Returns immediately and reports a successful start or reason for failure. The address must be aligned on a page boundary.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__group__hal__flash.html#gaab923541b1d1f71b0b9545306a9c559a" title="Gets flash characteristics like the start address, size, erase values etc. ">cyhal_flash_get_info()</a> to get the flash characteristics for legal address values and the page erase size.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>The Flash object being operated on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The address to start erasing from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status of the start_erase request.</dd></dl>
<p>Refer <a class="el" href="group__group__hal__flash.html#subsection_flash_use_case_3">Snippet 3: Non-blocking Flash Write Operation using polling</a> for more information. </p>

</div>
</div>
<a id="ga7de934ab80e8fcb82554735c98da3665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7de934ab80e8fcb82554735c98da3665">&#9670;&nbsp;</a></span>cyhal_flash_start_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__result.html#gaca79700fcc701534ce61778a9bcf57d1">cy_rslt_t</a> cyhal_flash_start_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__hal__impl__hw__types.html#structcyhal__flash__t">cyhal_flash_t</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts an asynchronous write to a single page of flash. </p>
<p>Returns immediately and reports a successful start or reason for failure. The address must be aligned on a page boundary.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__group__hal__flash.html#gaab923541b1d1f71b0b9545306a9c559a" title="Gets flash characteristics like the start address, size, erase values etc. ">cyhal_flash_get_info()</a> to get the flash characteristics for legal address values and the page write size. The provided data buffer must be at least as large as the flash page_size.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>The Flash object being operated on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The address to start writing to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data to write to flash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status of the start_write request.</dd></dl>
<p>Refer <a class="el" href="group__group__hal__flash.html#subsection_flash_use_case_3">Snippet 3: Non-blocking Flash Write Operation using polling</a> for more information. </p>

</div>
</div>
<a id="ga1e2ea114a8c7be82e928938e962adce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e2ea114a8c7be82e928938e962adce1">&#9670;&nbsp;</a></span>cyhal_flash_start_program()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__result.html#gaca79700fcc701534ce61778a9bcf57d1">cy_rslt_t</a> cyhal_flash_start_program </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__hal__impl__hw__types.html#structcyhal__flash__t">cyhal_flash_t</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts asynchronous programming of a single page of flash. </p>
<p>Returns immediately and reports a successful start or reason for failure.</p>
<dl class="section note"><dt>Note</dt><dd>Perform erase operation prior to calling this.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__group__hal__flash.html#gaab923541b1d1f71b0b9545306a9c559a" title="Gets flash characteristics like the start address, size, erase values etc. ">cyhal_flash_get_info()</a> to get the flash characteristics for legal address values and the total page size. The provided data buffer must be at least as large as the flash page_size.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>The Flash object being operated on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The address to start programming </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data to write to flash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status of the start_program request. Returns <a class="el" href="group__group__result.html#gaf58fac450d9fff4472f03ad68f6e546e">CY_RSLT_SUCCESS</a> on successful operation. </dd></dl>

</div>
</div>
<a id="gad3f9a6b2b2af077d862c98bb7aa624ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3f9a6b2b2af077d862c98bb7aa624ac">&#9670;&nbsp;</a></span>cyhal_flash_is_operation_complete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cyhal_flash_is_operation_complete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__hal__impl__hw__types.html#structcyhal__flash__t">cyhal_flash_t</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports status of the flash operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>The Flash object being operated on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if flash operation is complete. false otherwise. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>Hardware Abstraction Layer (HAL)</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
